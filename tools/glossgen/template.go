package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

var (
	templateFuncs = template.FuncMap{
		"cyberware": cyberware,
	}

	glossary = template.Must(
		template.New("struct").
			Funcs(templateFuncs).
			Parse(`----------------------------------
--     AUTOGENERATED FILE       --
-- File generated with glossgen --
----------------------------------

-- Internal glossary for enumeration, lookups, constants and so on.
local Glossary = {
    rootPath = "plugins.cyber_engine_tweaks.mods.bartmoss."
}

Glossary.Cyberware = { 
	Skeleton = { 
		Legendary = {
			{{- range $element := cyberware $.Objects "Skeleton" "Legendary"}}
			{{ $element }}
			{{- end}}
		},
		Epic = {
			{{- range $element := cyberware $.Objects "Skeleton" "Legendary"}}
			{{ $element }}
			{{- end}}
		},
		Rare = {
			{{- range $element := cyberware $.Objects "Skeleton" "Legendary"}}
			{{ $element }}
			{{- end}}
		},
		Uncommon = {
			{{- range $element := cyberware $.Objects "Skeleton" "Legendary"}}
			{{ $element }}
			{{- end}}
		},
		Common = {
			{{- range $element := cyberware $.Objects "Skeleton" "Legendary"}}
			{{ $element }}
			{{- end}}
		},
	}
}
`))
)

/*
// Copybook{{.Name}} contains a representation of your provided Copybook
type Copybook{{.Name}} struct {
	{{- range $element := .Records}}
		{{sanitiseName $element.Name}} {{goType $element.Picture $element.Occurs}} {{picTag $element.Length $element.Occurs}}{{indexComment $element.Length $element.Occurs}}
	{{- end}}
}
*/

func newGlossary(output string, d dict) error {
	f, err := os.Create(fmt.Sprintf("%s.lua", output))
	if err != nil {
		return err
	}

	if err := glossary.Execute(f, d); err != nil {
		return fmt.Errorf("failed to execute templater: %w", err)
	}

	// if _, err = f.Write(f.); err != nil {
	// 	return fmt.Errorf("failed to write output file: %w", err)
	// }

	return nil
}

func cyberware(objs map[string][]obj, slot, quality string) []string {
	var out []string

	qItems := objs[quality]
	for _, obj := range qItems {
		if obj.Slot == slot {
			out = append(out, fmt.Sprintf("%s = \"%s\",", obj.Name, obj.ID))
		}
	}

	if len(out) > 0 {
		last := len(out) - 1
		out[last] = strings.TrimSuffix(out[last], ",")
	}
	return out
}
